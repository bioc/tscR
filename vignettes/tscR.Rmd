---
title: "Clustering time series data with tscR"
subtitle: "A R package to cluster time series data, base on slope and Frechet distance"
author: 
- Pérez-Sanz, Fernando. Murcian Institute of biomedical research 
- Riquelme-Pérez, Miriam. CNRS - CEA, Univ. Paris-Saclay. MIRCen
output:
#  pdf_document:
#    toc: true
  prettydoc::html_pretty:
    theme: hpstr
    highlight: github
    toc: true
vignette: >
  %\VignetteIndexEntry{tscR}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, include=FALSE, comment=FALSE, echo=FALSE}
library(tscR)
library(tidyverse)
library(grid)
library(ggplot2)
library(latex2exp)
library(tscR)
library(TSdist)
```

# Overview

Clustering is an unsupervised learning technique widely used in several disciplines, such as machine learning, bioinformatics, image analysis or pattern recognition. Gene expression data clustering -- as well as in other omic disciplines -- is useful to find groups of genes with similar behavior and may provide very useful information for the understanding of certain biological processes.


This clustering of gene expression data can be performed onto genes, samples or over the time variable. In the last case, called 'time series genes expression', it is possible to identify genes with similar conduct and obtain sets of responses to certain situations. This has allowed to highlight (insight) environmental stress response, circadian rhythms pathway, treatment response, etc


Despite the fact that there are several generic R packages for the analysis of clustering time series -- _kmlShape_ , _dtwclust_, _clue_, _TSclust_ --, there is no a single algorithm that satisfactorily solves all problems and each clustering problem requires a specific approach. There are other specific packages to clustering time series in gene expression which seek minimize the high sensitivity to noise of other generic algorithms --  _TSMixclust_, _ctsGE_, _MFuzz_ -- . _MFuzz_ minimizes the high noise sensitivity of other algorithms through a fuzzy clustering, on the other hand _TSMixclust_ is a soft-clustering that uses mixed-effects models with non-parametric smoothing spline fitting. _ctsGE_ seeks to minimize noisy data in two steps, first define groups based on their expression profiles (expression index) and then, genes with same index are clustered by applying kmeans. Despite the fact that these methods attempt to solve the important task of minimizing the impact of the noise on clustering, genes with similar expression --in magnitude-- typically end up in the same groups, even though they have different temporal evolutions.


Occasionally, however, the researcher's main interest lies in finding genes with similar patterns (similar trajectories) although these occur at different levels of expression. Therefore, genes with a similar temporal evolution are therefore sought regardless of their magnitude of expression. 


Let us suppose that we subject an individual to a treatment and measure the expression of three (or ten thousand) of his genes at the time the treatment begins, at one week, two weeks and three weeks after (Fig. 1).

The lines in figure 1 (`a`,`b`,`c`) represent 3 tracks (e.g. the expression of 3 genes at 4 different times). The trajectories $T_a$ and $T_c$ are identical in terms of slopes, they only differ in the magnitude of their expression. On the other hand the track $T_b$ would be closer to the track $T_a$ than to $T_c$.

```{r warning=F, fig.cap="Figure 1", echo=FALSE}
a <- c(10, 15, 17, 25)
b <- c(5, 8, 6, 9 )
c <- c(-19, -14, -12, -4)
x <- c(1, 2, 3, 4)

df <- as.data.frame(cbind(x,a,b,c))

ggplot(df, aes(x=x))+ 
  geom_line(aes(y=a), color = "red")+
  geom_point(y=a, col="red")+
  geom_line(aes(y=b))+
  geom_point(y=b)+
  geom_line(aes(y=c), color = "steelblue")+
  geom_point(y=c, color="steelblue")+
  geom_label(aes(x=1.5, y=14, label = TeX("$S_{a1}$", output="character")), parse=TRUE   ) +
  geom_label(aes(x=2.5, y=17, label = TeX("$S_{a2}$", output="character")), parse=TRUE  ) +
  geom_label(aes(x=3.5, y=23, label = TeX("$S_{a3}$", output="character")), parse=TRUE  ) +
  geom_label(aes(x=1.5, y=7.5, label = TeX("$S_{b1}$", output="character")), parse=TRUE  ) +
  geom_label(aes(x=2.5, y=8, label = TeX("$S_{b2}$)", output="character")), parse=TRUE  ) +
  geom_label(aes(x=3.5, y=9, label = TeX("$S_{b3}$", output="character")), parse=TRUE  ) + 
  geom_label(aes(x=1.5, y=-15, label = TeX("$S_{c1}$", output="character")), parse=TRUE  ) +
  geom_label(aes(x=2.5, y=-12, label = TeX("$S_{c2}$", output="character")), parse=TRUE  ) +
  geom_label(aes(x=3.5, y=-7, label = TeX("$S_{c3}$", output="character")), parse=TRUE  ) +
  geom_text(aes(x=1, y=12, label = "Traject. a"))+
  geom_text(aes(x=1, y=4, label = "Traject. b"))+
  geom_text(aes(x=1, y=-17, label = "Traject. c"))+
  theme(legend.position = "none")+
  xlab("") + ylab("")

```

Intuitively, if we had to determine the distance between these trajectories, we would think that $T_a$ is closer to $T_b$ than to $T_c$. In addition, $T_c$ is closer to $T_b$ than to $T_a$. You could quantify those distances with different metrics:

* Euclidean distance

```{r echo=FALSE}
dfx <- as.matrix(rbind(a,b,c))
dsE <- round( dist(dfx, method = "euclidean", diag = FALSE, upper = FALSE), 3)
```

$$
\begin{matrix}
 & a &b \\ 
b & 21.24 & \\ 
c & 54.00 & 39.41 
\end{matrix}
$$

Other distance metrics based more specifically on time series such as Frechet or DTW provide similar results:

```{r echo=FALSE}
time <- c(1,2,3,4)
dF <- tscR::frechetDistC(dfx, time)
```

* Frechet Distance

$$
\begin{matrix}
 & a &b \\ 
b & 16 & \\ 
c & 29 & 24 
\end{matrix}
$$

* DTW Distance

```{r echo=FALSE}
dt1 <- DTWDistance(a,b)
dt2 <- DTWDistance(a,c)
dt3 <- DTWDistance(b,c)
```

$$
\begin{matrix}
 & a & b \\ 
b & 42 & \\ 
c & 158 & 104 
\end{matrix}
$$

However, if the main interest is to determine which trajectories have similar behaviour over time regardless of the magnitude of their expression, it is necessary to use purely geometric criteria and look for similarities based on their slopes. In this case, the distance matrix would look as follows:

$$
\begin{matrix}
 & a & b \\ 
b & 6.71 & \\ 
c & 0.00 & 6.71 
\end{matrix}
$$
Where it can be seen that the distance between the $a$ and $c$ trajectory is zero because these are two lines with identical slopes and the distance from both to $b$ is the same.

Therefore, we might find a researcher interested in identifying and grouping sets of genes with similar behaviours according to different points of view:

* Genes clustered with similar levels of expression, i.e. genes whose trajectories are close in terms of physical distance (fig.2 B).

* Genes grouped with similar evolution regardless of their physical distance. In this second scenario, we are dealing with genes that respond in a similar way, but with different intensity (fig.2 C).

* It might also be interesting to group genes according to both factors (distance + tendency) (fig.2 D).

```{r echo=FALSE, fig.align='center', fig.cap="Figure 2"}

df <- data.frame(T1 = c(140,100,75,35), T2=c(120,120,50,48), T3 = c(100,140,35,70))

df1 <- matrix(NA, nrow=10, ncol=3)
df2 <- matrix(NA, nrow=10, ncol=3)
df3 <- matrix(NA, nrow=10, ncol=3)
df4 <- matrix(NA, nrow=10, ncol=3)
for(i in seq(1,10)){
  df1[i,] <- jitter(as.numeric(df[1,]), factor = 1.5)
  df2[i,] <- jitter(as.numeric(df[2,]), factor = 1.5)
  df3[i,] <- jitter(as.numeric(df[3,]), factor = 1.5)
  df4[i,] <- jitter(as.numeric(df[4,]), factor = 1.5)
  }
df <- as.data.frame(rbind(df1,df2,df3,df4))
names(df) <- c("T1","T2","T3")

df <- as.data.frame.table(t(df))
df$Var3 <- rep(c("A","B","C","D"), each=30)

p1 <- df %>% 
ggplot( aes_(~Var1, ~Freq, group=~Var2) ) + 
  geom_line() + 
    theme(legend.position = "none", plot.title = element_text(hjust = 0.5)) + 
  xlab("(A)") + ylab("") + ggtitle(label = "Raw trajectories")

p2 <- df %>%
  mutate(Var4 = recode(Var3, "B" = "A")) %>%
  mutate(Var4 = recode(Var4, "D" = "C")) %>% 
ggplot( aes_(~Var1, ~Freq, group=~Var2, colour=~Var4) ) + 
  geom_line() +
  theme(legend.position = "none", plot.title = element_text(hjust = 0.5)) + 
  xlab("(B)") + ylab("") + ggtitle(label = "Frechet based cluster")

p3 <- df %>%
  mutate(Var4 = recode(Var3, "C" = "A")) %>%
  mutate(Var4 = recode(Var4, "D" = "B")) %>% 
ggplot( aes_(~Var1, ~Freq, group=~Var2, colour=~Var4) ) + 
  geom_line() +
  theme(legend.position = "none", plot.title = element_text(hjust = 0.5)) + 
  xlab("(C)") + ylab("") + ggtitle(label = "Slope based cluster")

p4 <- df %>%
ggplot( aes_(~Var1, ~Freq, group=~Var2, colour=~Var3) ) + 
  geom_line() +
  theme(legend.position = "none", plot.title = element_text(hjust = 0.5)) + 
  xlab("(D)") + ylab("") + ggtitle(label = "Combined clusters")


gridExtra::grid.arrange(p1,p2,p3,p4, nrow=2,
                        bottom = textGrob("Fig. 1",gp=gpar(fontsize=14,font=3)))

```

Con este paquete proponemos una metodología que permite agrupar esas trayectorias basándonos en distancias físicas empleando métrica de distancia adaptada a series temporales (distancia de Frechet) y una nueva aproximación basada en similitudes de pendientes de las trayectorias, donde éstas se agrupan en función de dicha similitud independientemente de la distancia a la que se encuentren.

Además se da la opción de combinar ambas clasificaciones de manera que el resultado final sería el de trayectorias agrupadas en base a sus valores y a sus evoluciones.

Puesto que en gran cantidad de estudios (especialmente en diferentes disciplinas ómicas), el número de trayectorias puede ser muy grande (miles o decenas de miles), se ha desarrollado una metodología basada en la existente en el paquete _kmlShape_, en la que mediante un preagrupamiento, se obtiene una serie de "representantes" de las trayectorias, denominados senators, estos senators son entonces clasificados mediante alguno de los algoritmos propuestos. Finalmente el conjunto de trayectorias es asignado al cluster al que su senator ha sido asignado. De esta manera se reduce el coste computacional y el riesgo de desbordar la memoria.

# Getting started

Install with `install_github`.

```{r eval = FALSE, echo=TRUE}
devtools::install_github("fpsanz/tscR")
```

Read the vignette (this document):

```{r eval = TRUE}
library(tscR)
```
```{r eval =FALSE}
browseVignettes("tscR")
```


# Simple clustering 

## Based on slope distance

Los datos de entrada deben ser un dataframe o matrix donde las filas serán cada una de las trayectorias
y las columnas los momentos en el tiempo (Table 1).

En primer lugar vamos a cargar un conjunto de trayectorias de ejemplo incluidas en la librería

```{r eval = TRUE, echo = TRUE}
data(tscR)
df <- tscR
head(df)
```

tscR contiene 300 observaciones (trayectorias) con datos tomados en 3 puntos temporales regulares (day 1, day 2, day 3).

```{r echo = F, eval=TRUE}
matplot(t(df), type = "l", col = "gray30", lty = 1, ylab = "")
```


A continuación se calcula la matrix de similitudes que será de tamaño n x n, siendo n el número de filas de la matriz de entrada. Esta matrix es un objeto de la clase `dist` y contiene las similitudes entre trayectorias basado en pendientes similares.

```{r eval = TRUE, echo = TRUE}
time <- c(1,2,3)
sDist <- slopeDist(df, time)
```

El siguiente paso sería agrupar las trayectorias basándonos en la similitud de sus pendientes independientemente de la distancia a la que se encuentren (meter referencia al paper).

```{r eval=TRUE}
sclust <- getClusters(sDist, k = 3)
```

El resultado puede ser visualizado con la función `plotCluster`. Esta función toma como parámetros los datos originales ( data ), el objeto resultante de `getClusters` ( cluster ) y los cluster que se desean visualizar: "all" para visulizarlos todos en un gráfico único, un entero para visulizar las trayectorias de ese cluster o un vector definiendo que clusters se desean visualizar (uno por subplot)

```{r eval=T, echo=T}
plotCluster(data = df, clust = sclust, ncluster = "all")
```

```{r eval=T, echo=T}
plotCluster(df, sclust, 1)
```

```{r eval=T, echo=T}
plotCluster(df, sclust, c(1:2))
```

Como puede observarse en este último gráfico, las trayectorias con evolución descedente-ascendente se han agrupado por un lado, independientemente de su distancia (plot izquierdo) y las de trayectoria ascendente-descentente por otro (plot derecho).

## Based on Frechet distance

Es una medida de similitud entre curvas que tiene en cuenta la localización y orden de los puntos a lo
largo de la curva (TODO: meter alguna referencia)

El procedimiento sería similar al caso anterior:

* Calcular la matriz de distancia.
* Obtener los clusters.
* Visualizar los resultados.

```{r eval = TRUE, echo = TRUE}
fdist <- frechetDistC(df, time)
fclust <- getClusters(fdist, 3)
plotCluster(df, fclust, "all")
```

Se observa que el agrupamiento tiene más que ver con la distancia (en términos euclídeos) entre trayectorias que con las pendientes en si mismas tal como se ilustra en el overview. En ciertas circustancias puede ser esta la clasificación que interese.

## Combined clusters

Una tercera opción es combinar los resultados de ambos agrupamientos de manera que se obtendran
conjuntos de trayectorias agrupados en función tanto de su distancia como de la similitud de sus pendientes.

Para ello, la función `combineCluster` toma como entrada los objetos generados por getClusters generando
una clasificación combinada.

De esta manera trayectorias muy cercanas pero con pendientes diferentes serán clasificadas en grupos diferentes y trayectorias con pendientes similares pero alejadas también se claficicarán en grupos diferentes. Así se obtiene una clasificación más fina (precisa) de las trayectorias.

```{r eval = TRUE, echo = TRUE}
ccluster <- combineCluster(sclust, fclust)
plotCluster(df, ccluster, c(1:6))
plotCluster(df, ccluster, "all")
```


# Clustering large data

En los casos en los que se dispone de una cantidad de trayectorias elevadas (>1000),
el coste computacional y de memoria puede ser muy elevado, principalmente cuando se trata de calcular las matrices de distancia. Nosotros proponemos hacer un clustering previo con la función `clara`, implementada dentro de `imputeSenators`, con un número de clusters elevado (p.e 100), esto generará 100 centroides, asumiendo que esos 100 centroides pueden representar al conjunto de formas de todas las trayectorias (de ahí el nombre de senators). Una vez obtenidos estos senators, se puede proceder con ellos como en el apartado anterior, agrupando en base distancia de Frechet, pendientes o ambas y generando el número de cluster deseados. Una vez obtenidos los clusters, como se ha guardado a que senator pertenecia cada trayectoria original, mediante `imputeSenatorToData` se asigna cada trayectoria
a los clusters finales.
Esta metodología permite clasificar un número muy elevado de trayectorias a un bajo coste computacional y de memoria.

El procedimiento, sería el siguiente: 

En primer lugar obtener los senators

```{r eval=T, echo=T}
data( "tscR" )
bigDF <- tscR
senators <- imputeSenators( bigDF, k = 100 )
```

El objeto generado (`senators`) es una lista de 3 elementos

* $data: dataframe con los datos originales
* $senatorData: es una matrix con las trajectorias de los senators
* $senatorCluster: vector con los clusters de los senators

Como ejemplo clasificaremos en función de la distancia basada en pendientes,
aunque como se ha mencionado anteriormente se podría hacer en base cualquiera 
de las distancias e incluso combinarlas.

```{r}
sdistSen <- frechetDistC( senators$senatorData, time = c( 1, 2, 3 ) ) 
cSenators <- getClusters( sdistSen, k = 4 )
```

Se podría visualizar la clasificación realizada a los senators

```{r}
plotCluster(senators$senatorData, cSenators, "all")
plotCluster(senators$senatorData, cSenators, c(1,2,3,4))
```

Finalmente, hay que asignar los datos originales a los nuevos cluster

```{r}
endCluster <- imputeSenatorToData(senators, cSenators)
```

Esto crea un objeto de la clase imputeSenator con 3 slots

* @data: contiene el data frame con los datos originales
* @senators: identifica cada dato de data a que senator pertenece
* @endcluster: contiene los clusters finales a los que han sido asignados los datos

Y la visualización

```{r}
plotClusterSenator(endCluster, "all")
plotClusterSenator(endCluster, c(1,2,3,4))
```


# References

Abanda, A. et  al. (2019).  A review on distance based time series classification. Data Mining and Knowledge Discovery,
33 (2), 378–412.

Ceccarello, M. et al. (2019). FRESH: Fréchet Similarity with Hashing. In Algorithms and data structures , pages 254–268. Springer. 

Eiter, T. and Mannila, H. (1994). Computing discrete Fréchet distance. Notes, 94, 64. 

Genolini, C. et al. (2016).  kmlShape: An efficient method to cluster longitudinal data (Time-Series) according to their shapes. PLoS ONE, 11 (6), e0150738.

Golumbeanu,  M. (2019).   TMixClust:  Time Series Clustering of Gene Expression with Gaussian Mixed-Effects Models and
Smoothing Splines. Hornik, K. (2005). A {CLUE} for {CLUster Ensembles}. Journal of Statistical Software, 14 (12).

Kumar, L. and Futschik, M. E. (2007). Mfuzz: A software package for soft clustering of microarray data. Bioinformation
,2 (1), 5–7.

Maechler, M. et  al. (2019). cluster: Cluster Analysis Basics and Extensions. 

McDowell, I. C. et al. (2018). Clustering gene expression time series data using an infinite Gaussian process mixture model.PLoS Computational Biology, 14 (1), e1005896.

Montero, P. and Vilar, J. A. (2014). TSclust: An R package for time series clustering. Journal of Statistical Software, 62 (1), 1–43.

Oyelade, J. et al. (2016). Clustering algorithms: Their application to gene expression data. Bioinformatics and Biology Insights, 10, 237–253. 

R Core Team (2019). R: A Language and Environment for Statistical Computing. 

Sardá-Espinosa, A.(2019). Time-Series Clustering in R Using the dtwclust Package. The R Journal.

Sharabi-Schwager, M. and Ophir, R. (2019). ctsGE: Clustering of Time Series Gene Expression data. 

Toohey, K. (2015). SimilarityMeasures: Trajectory Similari ty Measures

